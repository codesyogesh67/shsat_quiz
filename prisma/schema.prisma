// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  directUrl    = env("DIRECT_URL")
  relationMode = "foreignKeys"
}

enum Role {
  USER
  ADMIN
}

model User {
  id             String    @id @default(cuid())
  externalAuthId String    @unique // maps to Clerk user ID now; generic for future
  email          String?   @unique
  name           String?
  imageUrl       String?
  role           Role      @default(USER)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  Attempt        Attempt[]

  sessions Session[] @relation("UserSessions")
}

enum QuestionType {
  MULTIPLE_CHOICE
  FREE_RESPONSE
  GRID_IN
}

model Question {
  id          String       @id // stays as-is (existing 50 rows OK)
  externalId  String? // original JSON id (e.g., "Q58")
  examKey     String? // e.g., "shsat_2018", "shsat_2018_B", "random_questions"
  index       Int
  category    String?
  type        QuestionType @default(MULTIPLE_CHOICE) // enum for safety
  stem        String
  answer      String
  choices     Json? // MCQ options
  media       Json? // images/graphs metadata
  explanation String? // optional: store solution text/markdown
  tags        String[] // optional: quick filtering (Postgres text[])
  difficulty  Int? // optional: 1..5 or similar
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Optional: group questions by exam/paper; keep nullable so existing rows are fine
  examId String?
  exam   Exam?   @relation(fields: [examId], references: [id])

  attempts Attempt[]

  @@index([examKey, index])
  @@index([examKey, externalId])
}

model Exam {
  id        String   @id @default(cuid())
  key       String   @unique // e.g., "shsat_2023_A"
  year      Int?
  form      String? // e.g., "A", "B"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  questions Question[]

  sessions Session[]
}

model Attempt {
  id              String    @id @default(cuid())
  sessionId       String // ✅ required: every answer belongs to a session
  questionId      String
  userId          String? // stays optional (guest until claimed)
  givenAnswer     String?
  isCorrect       Boolean?
  flagged         Boolean   @default(false) // ✅ mark for review
  timeSpentSec    Int       @default(0) // ✅ cumulative
  firstAnsweredAt DateTime?
  updatedAt       DateTime  @updatedAt
  createdAt       DateTime  @default(now())

  session  Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user     User?    @relation(fields: [userId], references: [id])

  // ✅ exactly one attempt row per (session, question)
  @@unique([sessionId, questionId])
  @@index([questionId])
  @@index([userId])
  @@index([sessionId])
}

model Session {
  id           String    @id @default(cuid())
  userId       String?
  examId       String?
  examKey      String?
  label        String?
  mode         String
  startedAt    DateTime  @default(now())
  submittedAt  DateTime?
  scoreCorrect Int       @default(0)
  scoreTotal   Int       @default(0)
  minutes      Int?

  questionIds            String[] @db.Text
  progressCount          Int      @default(0)
  flagsCount             Int      @default(0)
  serverSecondsRemaining Int?

  user User? @relation("UserSessions", fields: [userId], references: [id])
  exam Exam? @relation(fields: [examId], references: [id])

  attempts Attempt[]

  @@index([userId])
  @@index([examKey])
}
